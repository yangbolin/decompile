<?xml version="1.0" encoding="GBK"?>
<list>
	<bytecode>
		<code>0x00</code>
		<symbol>nop</symbol>
		<operand>0</operand>
		<comment>什么都不做</comment>
	</bytecode>
	<bytecode>
		<code>0x01</code>
		<symbol>aconst_null</symbol>
		<operand>0</operand>
		<comment>将null推送至栈顶</comment>
	</bytecode>
	<bytecode>
		<code>0x02</code>
		<symbol>iconst_m1</symbol>
		<operand>0</operand>
		<comment>将int型-1推送至栈顶</comment>
	</bytecode>
	<bytecode>
		<code>0x03</code>
		<symbol>iconst_0</symbol>
		<operand>0</operand>
		<comment>将int型0推送至栈顶</comment>
	</bytecode>
	<bytecode>
		<code>0x04</code>
		<symbol>iconst_1</symbol>
		<operand>0</operand>
		<comment>将int型1推送至栈顶</comment>
	</bytecode>
	<bytecode>
		<code>0x05</code>
		<symbol>iconst_2</symbol>
		<operand>0</operand>
		<comment>将int型2推送至栈顶</comment>
	</bytecode>
	<bytecode>
		<code>0x06</code>
		<symbol>iconst_3</symbol>
		<operand>0</operand>
		<comment>将int型3推送至栈顶</comment>
	</bytecode>
	<bytecode>
		<code>0x07</code>
		<symbol>iconst_4</symbol>
		<operand>0</operand>
		<comment>将int型4推送至栈顶</comment>
	</bytecode>
	<bytecode>
		<code>0x08</code>
		<symbol>iconst_5</symbol>
		<operand>0</operand>
		<comment>将int型5推送至栈顶</comment>
	</bytecode>
	<bytecode>
		<code>0x09</code>
		<symbol>lconst_0</symbol>
		<operand>0</operand>
		<comment>将long型0推送至栈顶</comment>
	</bytecode>
	<bytecode>
		<code>0x0a</code>
		<symbol>lconst_1</symbol>
		<operand>0</operand>
		<comment>将long型1推送至栈顶</comment>
	</bytecode>
	<bytecode>
		<code>0x0b</code>
		<symbol>fconst_0</symbol>
		<operand>0</operand>
		<comment>将float型0推送至栈顶</comment>
	</bytecode>
	<bytecode>
		<code>0x0c</code>
		<symbol>fconst_1</symbol>
		<operand>0</operand>
		<comment>将float型1推送至栈顶</comment>
	</bytecode>
	<bytecode>
		<code>0x0d</code>
		<symbol>fconst_2</symbol>
		<operand>0</operand>
		<comment>将float型2推送至栈顶</comment>
	</bytecode>
	<bytecode>
		<code>0x0e</code>
		<symbol>dconst_0</symbol>
		<operand>0</operand>
		<comment>将double型0推送至栈顶</comment>
	</bytecode>
	<bytecode>
		<code>0x0f</code>
		<symbol>dconst_1</symbol>
		<operand>0</operand>
		<comment>将double型1推送至栈顶</comment>
	</bytecode>
	<bytecode>
		<code>0x10</code>
		<symbol>bipush</symbol>
		<operand>1</operand>
		<comment>将单字节的常量值(-128-127)推送至栈顶</comment>
	</bytecode>
	<bytecode>
		<code>0x11</code>
		<symbol>sipush</symbol>
		<operand>2</operand>
		<comment>将一个短整型常量值(-32768-32767)推送至栈顶</comment>
	</bytecode>
	<bytecode>
		<code>0x12</code>
		<symbol>ldc</symbol>
		<operand>1</operand>
		<comment>将int,float或者String型常量值从常量池中推送至栈顶</comment>
	</bytecode>
	<bytecode>
		<code>0x13</code>
		<symbol>ldc_w</symbol>
		<operand>2</operand>
		<comment>将int,float或者String型常量值从常量池中推送至栈顶(宽索引)</comment>
	</bytecode>
	<bytecode>
		<code>0x14</code>
		<symbol>ldc2_w</symbol>
		<operand>2</operand>
		<comment>将long或double型的常量值从常量池中推送至栈顶(宽索引)</comment>
	</bytecode>
	<bytecode>
		<code>0x15</code>
		<symbol>iload</symbol>
		<operand>1</operand>
		<comment>将指定的int型本地变量推送至栈顶</comment>
	</bytecode>
	<bytecode>
		<code>0x16</code>
		<symbol>lload</symbol>
		<operand>1</operand>
		<comment>将指定的long型本地变量推送至栈顶</comment>
	</bytecode>
	<bytecode>
		<code>0x17</code>
		<symbol>fload</symbol>
		<operand>1</operand>
		<comment>将指定的float型本地变量推送至栈顶</comment>
	</bytecode>
	<bytecode>
		<code>0x18</code>
		<symbol>dload</symbol>
		<operand>1</operand>
		<comment>将指定的double型本地变量推送至栈顶</comment>
	</bytecode>
	<bytecode>
		<code>0x19</code>
		<symbol>aload</symbol>
		<operand>1</operand>
		<comment>将指定的引用类型本地变量推送至栈顶</comment>
	</bytecode>
	<bytecode>
		<code>0x1a</code>
		<symbol>iload_0</symbol>
		<operand>0</operand>
		<comment>将第一个int型本地变量推送至栈顶</comment>
	</bytecode>
	<bytecode>
		<code>0x1b</code>
		<symbol>iload_1</symbol>
		<operand>0</operand>
		<comment>将第二个int型本地变量推送至栈顶</comment>
	</bytecode>
	<bytecode>
		<code>0x1c</code>
		<symbol>iload_2</symbol>
		<operand>0</operand>
		<comment>将第三个int型本地变量推送至栈顶</comment>
	</bytecode>
	<bytecode>
		<code>0x1d</code>
		<symbol>iload_3</symbol>
		<operand>0</operand>
		<comment>将第四个int型本地变量推送至栈顶</comment>
	</bytecode>
	<bytecode>
		<code>0x1e</code>
		<symbol>lload_0</symbol>
		<operand>0</operand>
		<comment>将第一个long型本地变量推送至栈顶</comment>
	</bytecode>
	<bytecode>
		<code>0x1f</code>
		<symbol>lload_1</symbol>
		<operand>0</operand>
		<comment>将第二个long型本地变量推送至栈顶</comment>
	</bytecode>
	<bytecode>
		<code>0x20</code>
		<symbol>lload_2</symbol>
		<operand>0</operand>
		<comment>将第三个long型本地变量推送至栈顶</comment>
	</bytecode>
	<bytecode>
		<code>0x21</code>
		<symbol>lload_3</symbol>
		<operand>0</operand>
		<comment>将第四个long型本地变量推送至栈顶</comment>
	</bytecode>
	<bytecode>
		<code>0x22</code>
		<symbol>fload_0</symbol>
		<operand>0</operand>
		<comment>将第一个float型本地变量推送至栈顶</comment>
	</bytecode>
	<bytecode>
		<code>0x23</code>
		<symbol>fload_1</symbol>
		<operand>0</operand>
		<comment>将第二个float型本地变量推送至栈顶</comment>
	</bytecode>
	<bytecode>
		<code>0x24</code>
		<symbol>fload_2</symbol>
		<operand>0</operand>
		<comment>将第三个float型本地变量推送至栈顶</comment>
	</bytecode>
	<bytecode>
		<code>0x25</code>
		<symbol>fload_3</symbol>
		<operand>0</operand>
		<comment>将第四个float型本地变量推送至栈顶</comment>
	</bytecode>
	<bytecode>
		<code>0x26</code>
		<symbol>dload_0</symbol>
		<operand>0</operand>
		<comment>将第一个double型本地变量推送至栈顶</comment>
	</bytecode>
	<bytecode>
		<code>0x27</code>
		<symbol>dload_1</symbol>
		<operand>0</operand>
		<comment>将第二个double型本地变量推送至栈顶</comment>
	</bytecode>
	<bytecode>
		<code>0x28</code>
		<symbol>dload_2</symbol>
		<operand>0</operand>
		<comment>将第三个double型本地变量推送至栈顶</comment>
	</bytecode>
	<bytecode>
		<code>0x29</code>
		<symbol>dload_3</symbol>
		<operand>0</operand>
		<comment>将第四个double型本地变量推送至栈顶</comment>
	</bytecode>
	<bytecode>
		<code>0x2a</code>
		<symbol>aload_0</symbol>
		<operand>0</operand>
		<comment>将第一个引用类型本地变量推送至栈顶</comment>
	</bytecode>
	<bytecode>
		<code>0x2b</code>
		<symbol>aload_1</symbol>
		<operand>0</operand>
		<comment>将第二个引用类型本地变量推送至栈顶</comment>
	</bytecode>
	<bytecode>
		<code>0x2c</code>
		<symbol>aload_2</symbol>
		<operand>0</operand>
		<comment>将第三个引用类型本地变量推送至栈顶</comment>
	</bytecode>
	<bytecode>
		<code>0x2d</code>
		<symbol>aload_3</symbol>
		<operand>0</operand>
		<comment>将第四个引用类型本地变量推送至栈顶</comment>
	</bytecode>
	<bytecode>
		<code>0x2e</code>
		<symbol>iaload</symbol>
		<operand>0</operand>
		<comment>将int型数组指定索引的值推送至栈顶</comment>
	</bytecode>
	<bytecode>
		<code>0x2f</code>
		<symbol>laload</symbol>
		<operand>0</operand>
		<comment>将long型数组指定索引的值推送至栈顶</comment>
	</bytecode>
	<bytecode>
		<code>0x30</code>
		<symbol>faload</symbol>
		<operand>0</operand>
		<comment>将float型数组指定索引的值推送至栈顶</comment>
	</bytecode>
	<bytecode>
		<code>0x31</code>
		<symbol>daload</symbol>
		<operand>0</operand>
		<comment>将double型数组指定索引的值推送至栈顶</comment>
	</bytecode>
	<bytecode>
		<code>0x32</code>
		<symbol>aaload</symbol>
		<operand>0</operand>
		<comment>将引用型数组指定索引的值推送至栈顶</comment>
	</bytecode>
	<bytecode>
		<code>0x33</code>
		<symbol>baload</symbol>
		<operand>0</operand>
		<comment>将boolean或byte型数组指定索引的值推送至栈顶</comment>
	</bytecode>
	<bytecode>
		<code>0x34</code>
		<symbol>caload</symbol>
		<operand>0</operand>
		<comment>将char型数组指定索引的值推送至栈顶</comment>
	</bytecode>
	<bytecode>
		<code>0x35</code>
		<symbol>saload</symbol>
		<operand>0</operand>
		<comment>将short型数组指定索引的值推送至栈顶</comment>
	</bytecode>
	<bytecode>
		<code>0x36</code>
		<symbol>istore</symbol>
		<operand>1</operand>
		<comment>将栈顶int型数值存入指定本地变量</comment>
	</bytecode>
	<bytecode>
		<code>0x37</code>
		<symbol>lstore</symbol>
		<operand>1</operand>
		<comment>将栈顶long型数值存入指定本地变量</comment>
	</bytecode>
	<bytecode>
		<code>0x38</code>
		<symbol>fstore</symbol>
		<operand>1</operand>
		<comment>将栈顶float型数值存入指定本地变量</comment>
	</bytecode>
	<bytecode>
		<code>0x39</code>
		<symbol>dstore</symbol>
		<operand>1</operand>
		<comment>将栈顶double型数值存入指定本地变量</comment>
	</bytecode>
	<bytecode>
		<code>0x3a</code>
		<symbol>astore</symbol>
		<operand>1</operand>
		<comment>将栈顶引用类型数值存入指定本地变量</comment>
	</bytecode>
	<bytecode>
		<code>0x3b</code>
		<symbol>istore_0</symbol>
		<operand>0</operand>
		<comment>将栈顶int型数值存入第一个本地变量</comment>
	</bytecode>
	<bytecode>
		<code>0x3c</code>
		<symbol>istore_1</symbol>
		<operand>0</operand>
		<comment>将栈顶int型数值存入第二个本地变量</comment>
	</bytecode>
	<bytecode>
		<code>0x3d</code>
		<symbol>istore_2</symbol>
		<operand>0</operand>
		<comment>将栈顶int型数值存入第三个本地变量</comment>
	</bytecode>
	<bytecode>
		<code>0x3e</code>
		<symbol>istore_3</symbol>
		<comment>将栈顶int型数值存入第四个本地变量</comment>
	</bytecode>
	<bytecode>
		<code>0x3f</code>
		<symbol>lstore_0</symbol>
		<operand>0</operand>
		<comment>将栈顶long型数值存入第一个本地变量</comment>
	</bytecode>
	<bytecode>
		<code>0x40</code>
		<symbol>lstore_1</symbol>
		<operand>0</operand>
		<comment>将栈顶long型数值存入第二个本地变量</comment>
	</bytecode>
	<bytecode>
		<code>0x41</code>
		<symbol>lstore_2</symbol>
		<operand>0</operand>
		<comment>将栈顶long型数值存入第三个本地变量</comment>
	</bytecode>
	<bytecode>
		<code>0x42</code>
		<symbol>lstore_3</symbol>
		<operand>0</operand>
		<comment>将栈顶long型数值存入第四个本地变量</comment>
	</bytecode>
	<bytecode>
		<code>0x43</code>
		<symbol>fload_0</symbol>
		<operand>0</operand>
		<comment>将栈顶float型数值存入第一个本地变量</comment>
	</bytecode>
	<bytecode>
		<code>0x44</code>
		<symbol>fload_1</symbol>
		<operand>0</operand>
		<comment>将栈顶float型数值存入第二个本地变量</comment>
	</bytecode>
	<bytecode>
		<code>0x45</code>
		<symbol>fload_2</symbol>
		<operand>0</operand>
		<comment>将栈顶float型数值存入第三个本地变量</comment>
	</bytecode>
	<bytecode>
		<code>0x46</code>
		<symbol>fload_3</symbol>
		<operand>0</operand>
		<comment>将栈顶float型数值存入第四个本地变量</comment>
	</bytecode>
	<bytecode>
		<code>0x47</code>
		<symbol>dstore_0</symbol>
		<operand>0</operand>
		<comment>将double型数值存入第一个本地变量</comment>
	</bytecode>
	<bytecode>
		<code>0x48</code>
		<symbol>dstore_1</symbol>
		<operand>0</operand>
		<comment>将栈顶double型数值存入第二个本地变量</comment>
	</bytecode>
	<bytecode>
		<code>0x49</code>
		<symbol>dstore_2</symbol>
		<operand>0</operand>
		<comment>将栈顶double型数值存入第三个本地变量</comment>
	</bytecode>
	<bytecode>
		<code>0x4a</code>
		<symbol>dstore_3</symbol>
		<operand>0</operand>
		<comment>将栈顶double型数值存入第四个本地变量</comment>
	</bytecode>
	<bytecode>
		<code>0x4b</code>
		<symbol>astore_0</symbol>
		<operand>0</operand>
		<comment>将栈顶引用类型数值存入第一个本地变量</comment>
	</bytecode>
	<bytecode>
		<code>0x4c</code>
		<symbol>astore_1</symbol>
		<operand>0</operand>
		<comment>将栈顶引用类型数值存入第二个本地变量</comment>
	</bytecode>
	<bytecode>
		<code>0x4d</code>
		<symbol>astore_2</symbol>
		<operand>0</operand>
		<comment>将栈顶引用类型数值存入第三个本地变量</comment>
	</bytecode>
	<bytecode>
		<code>0x4e</code>
		<symbol>astore_3</symbol>
		<operand>0</operand>
		<comment>将栈顶引用类型数值存入第四个本地变量</comment>
	</bytecode>
	<bytecode>
		<code>0x4f</code>
		<symbol>iastore</symbol>
		<operand>0</operand>
		<comment>将栈顶int型数值存入指定数组的指定索引位置</comment>
	</bytecode>
	<bytecode>
		<code>0x50</code>
		<symbol>lastore</symbol>
		<operand>0</operand>
		<comment>将栈顶long型数值存入指定数组的指定索引位置</comment>
	</bytecode>
	<bytecode>
		<code>0x51</code>
		<symbol>fastore</symbol>
		<operand>0</operand>
		<comment>将栈顶float型数值存入指定数组的指定索引位置</comment>
	</bytecode>
	<bytecode>
		<code>0x52</code>
		<symbol>dastore</symbol>
		<operand>0</operand>
		<comment>将栈顶double型数值存入指定数组的指定索引位置</comment>
	</bytecode>
	<bytecode>
		<code>0x53</code>
		<symbol>aastore</symbol>
		<operand>0</operand>
		<comment>将栈顶引用型数值存入指定数组的指定索引位置</comment>
	</bytecode>
	<bytecode>
		<code>0x54</code>
		<symbol>bastore</symbol>
		<operand>0</operand>
		<comment>将栈顶boolean或byte型数值存入指定数组的指定索引位置</comment>
	</bytecode>
	<bytecode>
		<code>0x55</code>
		<symbol>castore</symbol>
		<operand>0</operand>
		<comment>将栈顶char型数值存入指定数组的指定索引位置</comment>
	</bytecode>
	<bytecode>
		<code>0x56</code>
		<symbol>sastore</symbol>
		<operand>0</operand>
		<comment>将栈顶short型数值存入指定数组的指定索引位置</comment>
	</bytecode>
	<bytecode>
		<code>0x57</code>
		<symbol>pop</symbol>
		<operand>0</operand>
		<comment>将栈顶数值弹出(数值不能是long或者double类型的)</comment>
	</bytecode>
	<bytecode>
		<code>0x58</code>
		<symbol>pop2</symbol>
		<operand>0</operand>
		<comment>将栈顶一个(对于long或者double类型)或者两个数值(对于非long或double的其他类型)弹出</comment>
	</bytecode>
	<bytecode>
		<code>0x59</code>
		<symbol>dup</symbol>
		<operand>0</operand>
		<comment>复制栈顶数值并将复制值压入栈顶</comment>
	</bytecode>
	<bytecode>
		<code>0x5a</code>
		<symbol>dup_x1</symbol>
		<operand>0</operand>
		<comment>复制栈顶数值并将两个复制值压入栈顶</comment>
	</bytecode>
	<bytecode>
		<code>0x5b</code>
		<symbol>dup_x2</symbol>
		<operand>0</operand>
		<comment>复制栈顶数值并将三个复制(或两个)复制值压入栈顶</comment>
	</bytecode>
	<bytecode>
		<code>0x5c</code>
		<symbol>dup2</symbol>
		<operand>0</operand>
		<comment>复制栈顶一个(对于long或double类型)或者两个(对于非long或double的其他类型)数值并将复制值压入栈顶</comment>
	</bytecode>
	<bytecode>
		<code>0x5d</code>
		<symbol>dup2_x1</symbol>
		<operand>0</operand>
		<comment>dup_x1指令的双倍版本</comment>
	</bytecode>
	<bytecode>
		<code>0x5e</code>
		<symbol>dup2_x2</symbol>
		<operand>0</operand>
		<comment>dup_x2指令的双倍版本</comment>
	</bytecode>
	<bytecode>
		<code>0x5f</code>
		<symbol>swap</symbol>
		<operand>0</operand>
		<comment>将栈最顶端的两个数值互换(数值不能是long或者double类型)</comment>
	</bytecode>
	<bytecode>
		<code>0x60</code>
		<symbol>iadd</symbol>
		<operand>0</operand>
		<comment>将栈顶两int型数值相加并将结果压入栈顶</comment>
	</bytecode>
	<bytecode>
		<code>0x61</code>
		<symbol>ladd</symbol>
		<operand>0</operand>
		<comment>将栈顶两long型数值相加并将结果压入栈顶</comment>
	</bytecode>
	<bytecode>
		<code>0x62</code>
		<symbol>fadd</symbol>
		<operand>0</operand>
		<comment>将栈顶两float型数值相加并将结果压入栈顶</comment>
	</bytecode>
	<bytecode>
		<code>0x63</code>
		<symbol>dadd</symbol>
		<operand>0</operand>
		<comment>将栈顶两double型数值相加并将结果压入栈顶</comment>
	</bytecode>
	<bytecode>
		<code>0x64</code>
		<symbol>isub</symbol>
		<operand>0</operand>
		<comment>将栈顶两int型数值相减并将结果压入栈顶</comment>
	</bytecode>
	<bytecode>
		<code>0x65</code>
		<symbol>lsub</symbol>
		<operand>0</operand>
		<comment>将栈顶两long型数值相减并将结果压入栈顶</comment>
	</bytecode>
	<bytecode>
		<code>0x66</code>
		<symbol>fsub</symbol>
		<operand>0</operand>
		<comment>将栈顶两float型数值相减并将结果压入栈顶</comment>
	</bytecode>
	<bytecode>
		<code>0x67</code>
		<symbol>dsub</symbol>
		<operand>0</operand>
		<comment>将栈顶两double型数值相减并将结果压入栈顶</comment>
	</bytecode>
	<bytecode>
		<code>0x68</code>
		<symbol>imul</symbol>
		<operand>0</operand>
		<comment>将栈顶两int型数值相乘并将结果压入栈顶</comment>
	</bytecode>
	<bytecode>
		<code>0x69</code>
		<symbol>lmul</symbol>
		<operand>0</operand>
		<symbol>将栈顶两long型数值相乘并将结果压入栈顶</symbol>
	</bytecode>
	<bytecode>
		<code>0x6a</code>
		<symbol>fmul</symbol>
		<operand>0</operand>
		<comment>将栈顶两float型数值相乘并将结果压入栈顶</comment>
	</bytecode>
	<bytecode>
		<code>0x6b</code>
		<symbol>dmul</symbol>
		<operand>0</operand>
		<comment>将栈顶两double型数值相乘并将结果压入栈顶</comment>
	</bytecode>
	<bytecode>
		<code>0x6c</code>
		<symbol>idiv</symbol>
		<operand>0</operand>
		<comment>将栈顶两整型数值相除并将结果压入栈顶</comment>
	</bytecode>
	<bytecode>
		<code>0x6d</code>
		<symbol>ldiv</symbol>
		<operand>0</operand>
		<comment>将栈顶两long型数值相除并将结果压入栈顶</comment>
	</bytecode>
	<bytecode>
		<code>0x6e</code>
		<symbol>fdiv</symbol>
		<operand>0</operand>
		<comment>将栈顶两float型数值相除并将结果压入栈顶</comment>
	</bytecode>
	<bytecode>
		<code>0x6f</code>
		<symbol>ddiv</symbol>
		<operand>0</operand>
		<comment>将栈顶两double型数值相除并将结果压入栈顶</comment>
	</bytecode>
	<bytecode>
		<code>0x70</code>
		<symbol>irem</symbol>
		<operand>0</operand>
		<comment>将栈顶两int型数值作取模运算并将结果压入栈顶</comment>
	</bytecode>
	<bytecode>
		<code>0x71</code>
		<symbol>lrem</symbol>
		<operand>0</operand>
		<comment>将栈顶两long型数值作取模运算并将结果压入栈顶</comment>
	</bytecode>
	<bytecode>
		<code>0x72</code>
		<symbol>frem</symbol>
		<operand>0</operand>
		<comment>将栈顶两float型数值作取模运算并将结果压入栈顶</comment>
	</bytecode>
	<bytecode>
		<code>0x73</code>
		<symbol>drem</symbol>
		<operand>0</operand>
		<comment>将栈顶量double型数值作取模运算并将结果压入栈顶</comment>
	</bytecode>
	<bytecode>
		<code>0x74</code>
		<symbol>ineg</symbol>
		<operand>0</operand>
		<comment>将栈顶int型数值取负并将结果压入栈顶</comment>
	</bytecode>
	<bytecode>
		<code>0x75</code>
		<symbol>lneg</symbol>
		<operand>0</operand>
		<comment>将栈顶long型数值取负并将结果压入栈顶</comment>
	</bytecode>
	<bytecode>
		<code>0x76</code>
		<symbol>fneg</symbol>
		<operand>0</operand>
		<comment>将栈顶float型数值取负并将结果压入栈顶</comment>
	</bytecode>
	<bytecode>
		<code>0x77</code>
		<symbol>dneg</symbol>
		<operand>0</operand>
		<comment>将栈顶double型数值取负并将结果压入栈顶</comment>
	</bytecode>
	<bytecode>
		<code>0x78</code>
		<symbol>ishl</symbol>
		<operand>0</operand>
		<comment>将栈顶int型数值左移指定位数并将结果压入栈顶</comment>
	</bytecode>
	<bytecode>
		<code>0x79</code>
		<symbol>lshl</symbol>
		<operand>0</operand>
		<comment>将栈顶long型数值左移指定位数并将结果压入栈顶</comment>
	</bytecode>
	<bytecode>
		<code>0x7a</code>
		<symbol>ishr</symbol>
		<operand>0</operand>
		<comment>将栈顶int型数值(带符号)右移指定位数并将结果压入栈顶</comment>
	</bytecode>
	<bytecode>
		<code>0x7b</code>
		<symbol>lshr</symbol>
		<operand>0</operand>
		<comment>将栈顶long型数值(带符号)右移指定位数并将结果压入栈顶</comment>
	</bytecode>
	<bytecode>
		<code>0x7c</code>
		<symbol>iushr</symbol>
		<operand>0</operand>
		<comment>将栈顶int型数值(无符号)右移指定位数并将结果压入栈顶</comment>
	</bytecode>
	<bytecode>
		<code>0x7d</code>
		<symbol>lushr</symbol>
		<operand>0</operand>
		<comment>将栈顶long型数值(无符号)右移指定位数并将结果压入栈顶</comment>
	</bytecode>
	<bytecode>
		<code>0x7e</code>
		<symbol>iand</symbol>
		<operand>0</operand>
		<comment>将栈顶两int型数值作【按位与】并将结果压入栈顶</comment>
	</bytecode>
	<bytecode>
		<code>0x7f</code>
		<symbol>land</symbol>
		<operand>0</operand>
		<comment>将栈顶两long型数值作【按位与】并将结果压入栈顶</comment>
	</bytecode>
	<bytecode>
		<code>0x80</code>
		<symbol>ior</symbol>
		<operand>0</operand>
		<comment>将栈顶两int型数值作【按位或】并将结果压入栈顶</comment>
	</bytecode>
	<bytecode>
		<code>0x81</code>
		<symbol>lor</symbol>
		<operand>0</operand>
		<comment>将栈顶两long型数值作【按位或】并将结果压入栈顶</comment>
	</bytecode>
	<bytecode>
		<code>0x82</code>
		<symbol>ixor</symbol>
		<operand>0</operand>
		<comment>将栈顶两int型数值作【按位异或】并将结果压入栈顶</comment>
	</bytecode>
	<bytecode>
		<code>0x83</code>
		<symbol>lxor</symbol>
		<operand>0</operand>
		<comment>将栈顶两long型数值作【按位异或】并将结果压入栈顶</comment>
	</bytecode>
	<bytecode>
		<code>0x84</code>
		<symbol>iinc</symbol>
		<operand>2</operand>
		<comment>将指定int型变量增加指定值(如i++,i--,i+=2等)</comment>
	</bytecode>
	<bytecode>
		<code>0x85</code>
		<symbol>i2l</symbol>
		<operand>0</operand>
		<comment>将栈顶int型数值强制转换成long型数值并将结果压入栈顶</comment>
	</bytecode>
	<bytecode>
		<code>0x86</code>
		<symbol>i2f</symbol>
		<operand>0</operand>
		<comment>将栈顶int型数值强制转换成float型数值并将结果压入栈顶</comment>
	</bytecode>
	<bytecode>
		<code>0x87</code>
		<symbol>i2d</symbol>
		<operand>0</operand>
		<comment>将栈顶int型数值强制转换成double型数值并将结果压入栈顶</comment>
	</bytecode>
	<bytecode>
		<code>0x88</code>
		<symbol>l2i</symbol>
		<operand>0</operand>
		<symbol>将栈顶long型数值强制转换成int型数值并将结果压入栈顶</symbol>
	</bytecode>
	<bytecode>
		<code>0x89</code>
		<symbol>l2f</symbol>
		<operand>0</operand>
		<symbol>将栈顶long型数值强制转换成int型数值并将结果压入栈顶</symbol>
	</bytecode>
	<bytecode>
		<code>0x8a</code>
		<symbol>l2d</symbol>
		<operand>0</operand>
		<comment>将栈顶long型数值强制转换成double型数值并将结果压入栈顶</comment>
	</bytecode>
	<bytecode>
		<code>0x8b</code>
		<symbol>f2i</symbol>
		<operand>0</operand>
		<comment>将栈顶的float型数值强制转换成int型数值并将结果压入栈顶</comment>
	</bytecode>
	<bytecode>
		<code>0x8c</code>
		<symbol>f2l</symbol>
		<operand>0</operand>
		<comment>将栈顶float型数值强制转换成long型数值并将结果压入栈顶</comment>
	</bytecode>
	<bytecode>
		<code>0x8d</code>
		<symbol>f2d</symbol>
		<operand>0</operand>
		<comment>将栈顶float型数值强制转换成double型数值并将结果压入栈顶</comment>
	</bytecode>
	<bytecode>
		<code>0x8e</code>
		<symbol>d2i</symbol>
		<operand>0</operand>
		<comment>将栈顶double型的数值强制转换成int型数值并将结果压入栈顶</comment>
	</bytecode>
	<bytecode>
		<code>0x8f</code>
		<symbol>d2l</symbol>
		<operand>0</operand>
		<comment>将栈定double型数值强制转换成long型数值并将结果压入栈顶</comment>
	</bytecode>
	<bytecode>
		<code>0x90</code>
		<symbol>d2f</symbol>
		<operand>0</operand>
		<comment>将栈顶double型数值强制转换成float型数值并将结果压入栈顶</comment>
	</bytecode>
	<bytecode>
		<code>0x91</code>
		<symbol>i2b</symbol>
		<operand>0</operand>
		<comment>将栈顶int型数值强制转换成byte型数值并将结果压入栈顶</comment>
	</bytecode>
	<bytecode>
		<code>0x92</code>
		<symbol>i2c</symbol>
		<operand>0</operand>
		<comment>将栈顶int型数值强制转换成char型数值并将结果压入栈顶</comment>
	</bytecode>
	<bytecode>
		<code>0x93</code>
		<symbol>i2s</symbol>
		<operand>0</operand>
		<comment>将栈顶int型数值强制转换成short型数值并将结果压入栈顶</comment>
	</bytecode>
	<bytecode>
		<code>0x94</code>
		<symbol>lcmp</symbol>
		<operand>0</operand>
		<comment>比较栈顶两long型数值的大小，并将结果(1,0或-1)压入栈顶</comment>
	</bytecode>
	<bytecode>
		<code>0x95</code>
		<symbol>fcmpl</symbol>
		<operand>0</operand>
		<comment>比较栈顶两float型数值的大小，并将结果(1,0或-1)压入栈顶;当其中一个数值为"NAN"时，将-1压入栈顶</comment>
	</bytecode>
	<bytecode>
		<code>0x96</code>
		<symbol>fcmpg</symbol>
		<operand>0</operand>
		<comment>比较栈顶两float型数值的大小，并将结果(1,0或-1)压入栈顶;当其中一个数值为"NAN"时，将1压入栈顶</comment>
	</bytecode>
	<bytecode>
		<code>0x97</code>
		<symbol>dcmpl</symbol>
		<operand>0</operand>
		<comment>比较栈顶两double型数值的大小，并将结果(1,0或-1)压入栈顶;当其中一个数值为"NAN"时，将-1压入栈顶</comment>
	</bytecode>
	<bytecode>
		<code>0x98</code>
		<symbol>dcmpg</symbol>
		<operand>0</operand>
		<comment>比较栈顶两double型数值的大小，并将结果(1,0或-1)压入栈顶;当其中一个数值为"NAN"时，将1压入栈顶</comment>
	</bytecode>
	<bytecode>
		<code>0x99</code>
		<symbol>ifeq</symbol>
		<operand>3</operand>
		<comment>当栈顶int型数值等于0时跳转</comment>
	</bytecode>
	<bytecode>
		<code>0x9a</code>
		<symbol>ifne</symbol>
		<operand>3</operand>
		<comment>当栈顶int型数值不等于0时跳转</comment>
	</bytecode>
	<bytecode>
		<code>0x9b</code>
		<symbol>iflt</symbol>
		<operand>3</operand>
		<comment>当栈顶int型数值小于0时跳转</comment>
	</bytecode>
	<bytecode>
		<code>0x9c</code>
		<symbol>ifge</symbol>
		<operand>3</operand>
		<comment>当栈顶int型数值大于或等于0时跳转</comment>
	</bytecode>
	<bytecode>
		<code>0x9d</code>
		<symbol>ifgt</symbol>
		<operand>3</operand>
		<comment>当栈顶int型数值大于0时跳转</comment>
	</bytecode>
	<bytecode>
		<code>0x9e</code>
		<symbol>ifle</symbol>
		<operand>3</operand>
		<comment>当栈顶int型数值小于或等于0时跳转</comment>
	</bytecode>
	<bytecode>
		<code>0x9f</code>
		<symbol>if_icmpeq</symbol>
		<operand>3</operand>
		<comment>比较栈顶两int型数值的大小，当结果等于0时跳转</comment>
	</bytecode>
	<bytecode>
		<code>0xa0</code>
		<symbol>if_icmpne</symbol>
		<operand>3</operand>
		<comment>比较栈顶两int型数值的大小，当结果不等于0时跳转</comment>
	</bytecode>
	<bytecode>
		<code>0xa1</code>
		<symbol>if_icmplt</symbol>
		<operand>3</operand>
		<comment>比较栈顶两int型数值的大小，当结果小于0时跳转</comment>
	</bytecode>
	<bytecode>
		<code>0xa2</code>
		<symbol>if_icmpge</symbol>
		<operand>3</operand>
		<comment>比较栈顶两int型数值的大小，当结果大于等于0时跳转</comment>
	</bytecode>
	<bytecode>
		<code>0xa3</code>
		<symbol>if_icmpgt</symbol>
		<operand>3</operand>
		<comment>比较栈顶两int型数值的大小，当结果大于0时跳转</comment>
	</bytecode>
	<bytecode>
		<code>0xa4</code>
		<symbol>if_icmple</symbol>
		<operand>3</operand>
		<comment>比较栈顶两int型数值的大小，当结果小于等于0时跳转</comment>
	</bytecode>
	<bytecode>
		<code>0xa5</code>
		<symbol>if_acmpeq</symbol>
		<operand>3</operand>
		<comment>比较栈顶两引用型数值，当结果等于0时跳转</comment>
	</bytecode>
	<bytecode>
		<code>0xa6</code>
		<symbol>if_acmpne</symbol>
		<operand>3</operand>
		<comment>比较栈顶两引用型数值，当结果不等于0时跳转</comment>
	</bytecode>
	<bytecode>
		<code>0xa7</code>
		<symbol>goto</symbol>
		<operand>3</operand>
		<comment>无条件跳转</comment>
	</bytecode>
	<bytecode>
		<code>0xa8</code>
		<symbol>jsr</symbol>
		<operand>3</operand>
		<comment>跳转至指定的16位offset位置，并将jsr的下一条指令地址压入栈顶</comment>
	</bytecode>
	<bytecode>
		<code>0xa9</code>
		<symbol>ret</symbol>
		<operand>4</operand>
		<comment>返回至本地变量指定的index的指令位置(一般与jsr或jsr_w联合使用)</comment>
	</bytecode>
	<bytecode>
		<code>0xaa</code>
		<symbol>tableswitch</symbol>
		<operand>5</operand>
		<comment>用于switch条件跳转，case值连续(可变长度指令)</comment>
	</bytecode>
	<bytecode>
		<code>0xab</code>
		<symbol>lookupswitch</symbol>
		<operand>6</operand>
		<comment>用于switch条件跳转，case值不连续(可变长度指令)</comment>
	</bytecode>
	<bytecode>
		<code>0xac</code>
		<symbol>ireturn</symbol>
		<operand>0</operand>
		<comment>从当前方法返回int</comment>
	</bytecode>
	<bytecode>
		<code>0xad</code>
		<symbol>lreturn</symbol>
		<operand>0</operand>
		<comment>从当前方法返回long</comment>
	</bytecode>
	<bytecode>
		<code>0xae</code>
		<symbol>freturn</symbol>
		<operand>0</operand>
		<comment>从当前方法返回float</comment>
	</bytecode>
	<bytecode>
		<code>0xaf</code>
		<symbol>dreturn</symbol>
		<operand>0</operand>
		<comment>从当前方法返回double</comment>
	</bytecode>
	<bytecode>
		<code>0xb0</code>
		<symbol>areturn</symbol>
		<operand>0</operand>
		<comment>从当前方法返回对象引用</comment>
	</bytecode>
	<bytecode>
		<code>0xb1</code>
		<symbol>return</symbol>
		<operand>0</operand>
		<comment>从当前方法返回void</comment>
	</bytecode>
	<bytecode>
		<code>0xb2</code>
		<symbol>getstatic</symbol>
		<operand>7</operand>
		<comment>获取指定类的静态域，并将其值压入栈顶</comment>
	</bytecode>
	<bytecode>
		<code>0xb3</code>
		<symbol>putstatic</symbol>
		<operand>7</operand>
		<comment>为指定类的静态域赋值</comment>
	</bytecode>
	<bytecode>
		<code>0xb4</code>
		<symbol>getfield</symbol>
		<operand>7</operand>
		<comment>获取指定类的实例域，并将其值压入栈顶</comment>
	</bytecode>
	<bytecode>
		<code>0xb5</code>
		<symbol>putfield</symbol>
		<operand>7</operand>
		<comment>为指定类的实例域赋值</comment>
	</bytecode>
	<bytecode>
		<code>0xb6</code>
		<symbol>invokevirtual</symbol>
		<operand>8</operand>
		<comment>调用实例方法</comment>
	</bytecode>
	<bytecode>
		<code>0xb7</code>
		<symbol>invokespecial</symbol>
		<operand>8</operand>
		<comment>调用超类构造方法，实例初始化方法，私有方法</comment>		
	</bytecode>
	<bytecode>
		<code>0xb8</code>
		<symbol>invokestatic</symbol>
		<operand>8</operand>
		<comment>调用静态方法</comment>
	</bytecode>
	<bytecode>
		<code>0xb9</code>
		<symbol>invokeinterface</symbol>
		<operand>9</operand>
		<comment>调用接口方法</comment>
	</bytecode>
	<bytecode>
		<code>0xba</code>
		<symbol>--</symbol>
		<comment>无此指令</comment>
	</bytecode>
	<bytecode>
		<code>0xbb</code>
		<symbol>new</symbol>
		<operand>10</operand>
		<comment>创建一个对象，并将其引用值压入栈顶</comment>
	</bytecode>
	<bytecode>
		<code>0xbc</code>
		<symbol>newarray</symbol>
		<operand>11</operand>
		<comment>创建一个指定的原始类型(如int,float,char等)的数组，并将其引用值压入栈顶</comment>
	</bytecode>
	<bytecode>
		<code>0xbd</code>
		<symbol>anewarray</symbol>
		<operand>12</operand>
		<comment>创建一个引用类型(如类，接口，数组)的数组，并将期引用值压入栈顶</comment>
	</bytecode>
	<bytecode>
		<code>0xbe</code>
		<symbol>arraylength</symbol>
		<operand>0</operand>
		<comment>获得数组长度值并压入栈顶</comment>
	</bytecode>
	<bytecode>
		<code>0xbf</code>
		<symbol>athrow</symbol>
		<operand>0</operand>
		<comment>将栈顶的异常抛出</comment>
	</bytecode>
	<bytecode>
		<code>0xc0</code>
		<symbol>checkcast</symbol>
		<operand>14</operand>
		<comment>检验类型转换，检验未通过将抛出ClassCastException</comment>
	</bytecode>
	<bytecode>
		<code>0xc1</code>
		<symbol>intanceof</symbol>
		<operand>14</operand>
		<comment>检验对象是否是指定的实例，如果是将1压入栈顶，如果不是将0压入栈顶</comment>
	</bytecode>
	<bytecode>
		<code>0xc2</code>
		<symbol>monitorenter</symbol>
		<operand>0</operand>
		<comment>获得对象的锁，用户同步方法或同步块</comment>
	</bytecode>
	<bytecode>
		<code>0xc3</code>
		<symbol>monitorexit</symbol>
		<operand>0</operand>
		<comment>释放对象的锁，用户同步方法或同步块</comment>
	</bytecode>
	<bytecode>
		<code>0xc4</code>
		<symbol>wide</symbol>
		<operand>-1</operand>
		<comment>扩展本地变量的宽度</comment>
	</bytecode>
	<bytecode>
		<code>0xc5</code>
		<symbol>multianewarray</symbol>
		<operand>13</operand>
		<comment>创建指定类型和指定维度的多维数组(执行该指令时，操作栈中必须包含各维度的长度值)，并将其引用值压入栈</comment>
	</bytecode>
	<bytecode>
		<code>0xc6</code>
		<symbol>ifnull</symbol>
		<operand>3</operand>
		<comment>为null时跳转</comment>
	</bytecode>
	<bytecode>
		<code>0xc7</code>
		<symbol>ifnonull</symbol>
		<operand>3</operand>
		<comment>不为null时跳转</comment>
	</bytecode>
	<bytecode>
		<code>0xc8</code>
		<symbol>goto_w</symbol>
		<operand>15</operand>
		<comment>无条件跳转(宽索引)</comment>
	</bytecode>
	<bytecode>
		<code>0xc9</code>
		<symbol>jsr_w</symbol>
		<operand>15</operand>
		<comment>跳转至32位的offset位置，并将jsr_w的下一条指令地址压入栈顶</comment>
	</bytecode>
</list>